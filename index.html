<!DOCTYPE html>
<html>
  <head>
    <title>Space Maze Flyer</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: black; /* Default black background; stars will be drawn in JavaScript */
      }

      canvas {
        border: 1px solid black;
        background-color: #000;
        display: block;
      }

      .game-container {
        text-align: center;
        font-family: Arial, sans-serif;
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #map-selection {
        display: block;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        z-index: 10;
      }

      #game-over,
      #game-won,
      #start-message {
        display: none;
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 24px;
        text-align: center;
        z-index: 10;
      }

      #game-over {
        color: red;
      }

      #game-won {
        color: green;
      }

      #restart-btn,
      #back-btn {
        display: none;
        position: absolute;
        top: 60%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 10px 20px;
        font-size: 18px;
        z-index: 10;
      }

      #leaderboard-container {
        position: absolute;
        top: 40px;
        right: 10px;
        color: black;
        font-size: 16px;
        text-align: right;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 5px;
        z-index: 10;
      }

      #leaderboard {
        display: none;
      }

      #leaderboard-btn {
        cursor: pointer;
        background-color: #ddd;
        border: none;
        padding: 2px 5px;
      }

      @font-face {
        font-family: 'Digital-7';
        src: url('C:/Windows/Fonts/Digital-7.ttf') format('truetype');
      }
    </style>
  </head>
  <body>
<div id="leaderboard" style="display: none;"></div>
<div class="game-container">
  <canvas id="gameCanvas"></canvas>
  <div id="map-selection">
    <h1 style="color: #A9A9FF; font-size: 48px; font-family: Arial, sans-serif;">Space Ace</h1>
    <button onclick="selectMap(0)" style="background-color: #00FF00; color: black; padding: 10px 20px; font-size: 18px; margin: 5px; cursor: pointer;">Map 1</button><br>
    <button onclick="selectMap(1)" style="background-color: #00FF00; color: black; padding: 10px 20px; font-size: 18px; margin: 5px; cursor: pointer;">Map 2</button><br>
    <button onclick="selectMap(2)" style="background-color: #00FF00; color: black; padding: 10px 20px; font-size: 18px; margin: 5px; cursor: pointer;">Map 3</button><br>
    <button onclick="resetBestTimes()" style="background-color: #00FF00; color: black; padding: 10px 20px; font-size: 18px; margin: 5px; cursor: pointer;">Reset Timer</button>
  </div>
  <div id="game-over">Game Over! Press Space to Restart</div>
  <div id="game-won">You Won! Press Space to Restart</div>
  <div id="start-message">Controls:<br>Arrows to Turn<br>Space to Thrust<br>Press Space to Start</div>
  <button id="restart-btn" onclick="restartGame()">Restart</button>
    <audio id="thrustSound" loop>
    <source src="data:audio/wav;base64,[PASTE THRUST SOUND BASE64 HERE]"></source>
  </audio>
  <audio id="explosionSound">
    <source src="data:audio/wav;base64,[PASTE EXPLOSION SOUND BASE64 HERE]"></source>
  </audio>
  <audio id="blobSound">
    <source src="data:audio/wav;base64,[PASTE BLOB SOUND BASE64 HERE]"></source>
  </audio>
</div>
    <script>
      // Global variables
      let canvas, ctx, gameOverText, gameWonText, startMessage, restartBtn, thrustSound, explosionSound, blobSound, leaderboardDisplay, leaderboardBtn;
      let bestTime = Infinity;
      let leaderboard = JSON.parse(localStorage.getItem("leaderboard")) || [];
      if (leaderboard.length > 0) {
        bestTime = Math.min(...leaderboard); // Set best time to the fastest time in leaderboard
      }

      let lastTime = 0;
      let stars = [];
      const maxStars = 200; // Maximum number of stars
      const spawnInterval = 120; // Spawn a new star every 2 seconds at 60 FPS
      const starLifespan = 300; // Base lifespan of each star in frames (5 seconds at 60 FPS)
      let frameCount = 0; // Frame counter for star spawning and disappearance
      let lastStarSpawn = 0; // Frame counter for tracking when to spawn new stars
      let lastDisappearance = 0; // Frame counter for tracking last disappearance event
      const disappearanceInterval = 300; // Random disappearance occurs every 5 seconds (300 frames at 60 FPS)

      const mapWidth = 600;
      const mapHeight = 400;
      const zoomFactor = 1.5;
      const viewWidth = mapWidth / zoomFactor;
      const viewHeight = mapHeight / zoomFactor;

      let cameraX = 0;
      let cameraY = 0;
      const cameraSmoothing = 0.1;

      let ship = {
        x: 70,
        y: 366.5,
        angle: Math.PI / 2,
        targetAngle: Math.PI / 2,
        speedX: 0,
        speedY: 0,
        maxSpeed: 2.6,
        thrust: 0.090,
        thrustIncrement: 0.016,
        currentThrust: 0,
        turnSpeed: Math.PI * 2.05,
        size: 13.5,
        frozen: true,
        visible: true
      };

      let gameState = 'mapSelection'; // Initial state
      let currentMapIndex = null;
      let isThrusting = false;
      let isTurningLeft = false;
      let isTurningRight = false;
      const gravity = 0.020;

      let startTime = 0;
      let elapsedTime = 0;
      let timerRunning = false;

      let explosion = {
        active: false,
        x: 0,
        y: 0,
        radius: 0,
        maxRadius: 50,
        duration: 30,
        frame: 0,
      };

      let thrustAnimation = {
        active: false,
        frame: 0,
        maxLength: 20,
        width: 8,
      };

      const maps = [
        {
          maze: [
            [0, 0, 600, 20], // Top wall
            [0, 380, 600, 20], // Bottom wall
            [0, 0, 20, 400], // Left wall
            [580, 0, 20, 400], // Right wall
            [100, 100, 400, 20],
            [100, 200, 20, 200],
            [200, 0, 20, 300],
            [300, 100, 20, 200],
            [400, 200, 200, 20],
          ],
          balls: [
            [150, 50],
       //     [250, 150],
        //    [350, 250],
        //    [450, 50],
         //   [550, 300],
          ],
        },
        {
          maze: [
            [50, 20, 500, 20],   // Top horizontal
            [50, 360, 500, 20],  // Bottom horizontal
            [20, 50, 20, 300],   // Left vertical
            [560, 50, 20, 300],  // Right vertical
            [50, 20, 20, 50],    // Top-left diagonal
            [530, 20, 20, 50],   // Top-right diagonal
            [50, 360, 20, 50],   // Bottom-left diagonal
            [530, 360, 20, 50],  // Bottom-right diagonal
            [150, 100, 300, 10],  // Top inner horizontal
            [150, 290, 300, 10],  // Bottom inner horizontal
            [180, 130, 20, 100],  // Left vertical
            [400, 130, 20, 100],  // Right vertical
            [250, 180, 100, 10],  // Middle horizontal
            [250, 220, 100, 10]   // Lower middle horizontal
          ],
          balls: [
            [100, 100],
            [200, 200],
            [300, 300],
            [400, 100],
            [500, 200],
          ],
        },
        {
          maze: [
            [0, 0, 600, 20],
            [0, 380, 600, 20],
            [0, 0, 20, 400],
            [580, 0, 20, 400],
            [150, 100, 300, 20],
            [150, 200, 20, 100],
            [430, 200, 20, 100],
            [250, 250, 100, 20],
            [300, 150, 20, 100],
          ],
          balls: [
            [120, 80],
            [220, 180],
            [320, 280],
            [420, 80],
            [520, 180],
          ],
        },
      ];

      let maze = [];
      let balls = [];
      let ballsTotal = 0;

      // Initialize DOM elements and canvas after the DOM is loaded
      document.addEventListener("DOMContentLoaded", () => {
	    backBtn = document.getElementById("back-btn");
        if (!backBtn) console.warn("Warning: backBtn not found.");
        canvas = document.getElementById("gameCanvas");
        ctx = canvas.getContext("2d");
        gameOverText = document.getElementById("game-over");
        gameWonText = document.getElementById("game-won");
        startMessage = document.getElementById("start-message");
        restartBtn = document.getElementById("restart-btn");
        thrustSound = document.getElementById("thrustSound");
        thrustSound.volume = 0.5;
        explosionSound = document.getElementById("explosionSound");
        explosionSound.volume = 0.9;
        blobSound = document.getElementById("blobSound");
        blobSound.volume = 0.5;
        leaderboardDisplay = document.getElementById("leaderboard");
        leaderboardBtn = document.getElementById("leaderboard-btn");

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        initStars();
        gameLoop();
      });

      function initStars() {
        for (let i = 0; i < maxStars; i++) {
          stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 2 + 1,
            age: 0,
            lifespan: starLifespan
          });
        }
      }
	  
	  function stopSound(sound) {
    if (sound && !sound.paused) {
        sound.pause();
        sound.currentTime = 0;
    }
}

      function updateStars() {
        frameCount++;
        // Remove expired stars
        stars = stars.filter(star => star.age++ < star.lifespan);
        
        // Add a new star every 2 seconds if below max
        if (frameCount % spawnInterval === 0 && stars.length < maxStars) {
          stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 2 + 1,
            age: 0,
            lifespan: starLifespan
          });
        }
      }

      window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        if (gameState === 'mapSelection') {
          initStars(); // Reinitialize stars to match new size
        }
      });

      document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape' || event.keyCode === 27) {
          gameState = 'mapSelection';
          document.getElementById('map-selection').style.display = 'block';
          document.getElementById('game-over').style.display = 'none';
          document.getElementById('game-won').style.display = 'none';
          document.getElementById('start-message').style.display = 'none';
          document.getElementById('ranking-screen').style.display = 'none';
          document.getElementById('practice-screen').style.display = 'none';
          if (typeof thrustSound !== 'undefined') thrustSound.pause();
          if (typeof explosionSound !== 'undefined') explosionSound.pause();
          if (typeof backgroundMusic !== 'undefined') backgroundMusic.pause();
        }
      });
	  
	  function resetBestTimes() {
  // Clear the leaderboard from localStorage
  localStorage.removeItem("leaderboard");
  // Reset the leaderboard array and bestTime
  leaderboard = [];
  bestTime = Infinity;
  // Optionally, update the leaderboard display (if visible)
  leaderboardDisplay.innerHTML = "-";
  console.log("Best times reset successfully.");
}

      function selectMap(mapIndex) {
        currentMapIndex = mapIndex;
        maze = maps[mapIndex].maze;
        balls = maps[mapIndex].balls.map(pos => [...pos, false]); // Reset balls to uncollected
        ballsTotal = balls.length; // Set total balls for this map
        document.getElementById("map-selection").style.display = "none";
        startMessage.style.display = "block";
        gameState = 'paused';
        restartGame();
        backBtn.style.display = "block"; // Show back button after map selection
      }

document.addEventListener("keydown", (e) => {
    if (gameState === 'mapSelection') return;

    if (gameState === 'gameOver' || gameState === 'gameWon') {
        if (e.key === " ") {
            console.log("Restarting after win...");
            restartGame();
        }
        return;
    }

    if (gameState === 'paused') {
        if (e.key === " ") {
            gameState = 'playing';
            startMessage.style.display = "none";
            timerRunning = true;
            startTime = Date.now();
        }
        return;
    }

    switch (e.key) {
        case "ArrowLeft":
        case "a":
            isTurningLeft = true;
            break;
        case "ArrowRight":
        case "d":
            isTurningRight = true;
            break;
        case " ":
            isThrusting = true;
            if (ship.frozen) {
                ship.frozen = false; // Unfreeze the ship only when thrust is applied
                console.log("Ship is now unfrozen!");
            }
            thrustAnimation.active = true;
            thrustSound.play();
            e.preventDefault();
            break;
    }
});



      document.addEventListener("keyup", (e) => {
        switch (e.key) {
          case "ArrowLeft":
          case "a":
          case "A":
            isTurningLeft = false;
            break;
          case "ArrowRight":
          case "d":
          case "D":
            isTurningRight = false;
            break;
          case " ":
            isThrusting = false;
            thrustAnimation.active = false;
            thrustAnimation.frame = 0;
            thrustSound.pause();
            thrustSound.currentTime = 0;
            break;
        }
      });

      function checkCollision(x, y) {
        for (let wall of maze) {
          const shipLeft = x - ship.size / 2;
          const shipRight = x + ship.size / 2;
          const shipTop = y - ship.size / 2;
          const shipBottom = y + ship.size / 2;
          if (
            shipRight > wall[0] &&
            shipLeft < wall[0] + wall[2] &&
            shipBottom > wall[1] &&
            shipTop < wall[1] + wall[3]
          ) {
            return true;
          }
        }
        return false;
      }

      function checkBallCollision(x, y) {
        balls.forEach((ball) => {
          if (!ball[2]) {
            const distance = Math.hypot(x - ball[0], y - ball[1]);
            if (distance < (ship.size / 2) + 5) {
              ball[2] = true;
              blobSound.play().catch(error => console.log("Blob sound play failed:", error)); // Play sound on collection
            }
          }
        });
      }

function updateTimer() {
  if (gameState !== 'mapSelection') {
    const miniMapWidth = 150;
    const miniMapHeight = 100;
    const timerWidth = 200; // Width of the timer box
    const timerHeight = 40; // Height of the timer box
    const padding = 10; // Padding around mini-map and timer

    // Position timer to the right of mini-map
    const timerX = miniMapWidth + padding * 2 + 10; // Right of mini-map with padding
    const timerY = padding; // Top of screen, aligned with mini-map

    // Count balls left (false means not collected)
    const ballsLeft = balls.filter(ball => !ball[2]).length;

    ctx.save();
    ctx.fillStyle = "purple"; // Border color
    ctx.fillRect(timerX - 2, timerY - 2, timerWidth + 4, timerHeight + 4); // Purple border
    ctx.fillStyle = "#1A0D2B"; // Dark background (matches the image)
    ctx.fillRect(timerX, timerY, timerWidth, timerHeight);

    ctx.font = "24px 'Digital-7', Arial"; // Use a digital-style font (you may need to load 'Digital-7' or use a similar monospace font)
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // Best time (left, pink) - moved left and spaced out
    ctx.fillStyle = "#FF69B4"; // Pink for best time
    ctx.fillText(`${bestTime === Infinity ? "0.0" : bestTime.toFixed(1)}`, timerX + 40, timerY + timerHeight / 2);

    // Current time (middle, pink) - spaced out further
    ctx.fillStyle = "#FF69B4"; // Pink for current time
    ctx.fillText(`${elapsedTime.toFixed(1)}`, timerX + 120, timerY + timerHeight / 2);

    // Balls left (right, green) - moved further right within the box
    ctx.fillStyle = "#00FF00"; // Green for balls left
    ctx.fillText(`${ballsLeft}`, timerX + 180, timerY + timerHeight / 2);

    ctx.restore();
  }
}

function updateLeaderboard() {
  if (!leaderboardDisplay) {
    console.warn("Leaderboard display element not found.");
    return;
  }

  if (gameState === 'gameWon' && elapsedTime > 0) {
    leaderboard.push(elapsedTime);
    leaderboard.sort((a, b) => a - b); // Sort in ascending order (fastest first)
    leaderboard = leaderboard.slice(0, 5); // Keep top 5 times
    localStorage.setItem("leaderboard", JSON.stringify(leaderboard));

    // Update best time (smallest elapsedTime)
    bestTime = leaderboard.length > 0 ? leaderboard[0] : Infinity;
  }

  let leaderboardText = "";
  leaderboard.forEach((score, index) => {
    leaderboardText += `${index + 1}. ${score.toFixed(3)}s<br>`;
  });

  leaderboardDisplay.innerHTML = leaderboardText || "-";
}


      function toggleLeaderboard() {
        leaderboardDisplay.style.display = leaderboardDisplay.style.display === "block" ? "none" : "block";
      }

      function drawShip(x, y, scale) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(-ship.angle);
        ctx.scale(scale, scale);
        ctx.beginPath();
        ctx.moveTo(ship.size, 0);
        ctx.lineTo(-ship.size / 2, ship.size / 2);
        ctx.lineTo(-ship.size / 2, -ship.size / 2);
        ctx.closePath();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }

      function backToMapSelection() {
        gameState = 'mapSelection';
        ship.visible = true; // Ensure ship is visible if returning
        explosion.active = false;
        thrustAnimation.active = false;
        thrustAnimation.frame = 0;
        gameOverText.style.display = "none";
        gameWonText.style.display = "none";
        startMessage.style.display = "none";
        restartBtn.style.display = "none";
        backBtn.style.display = "none"; // Hide back button
        document.getElementById("map-selection").style.display = "block";
        leaderboardDisplay.style.display = "none";
        thrustSound.pause();
        thrustSound.currentTime = 0;
        explosionSound.pause();
        explosionSound.currentTime = 0;
        blobSound.pause();
        blobSound.currentTime = 0;
        timerRunning = false;
        cameraX = 0; // Reset camera if needed
        cameraY = 0;
      }

      function drawThrust(x, y, scale) {
        if (thrustAnimation.active) {
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(-ship.angle);
          ctx.scale(scale, scale);
          const length = (thrustAnimation.maxLength * (Math.sin(thrustAnimation.frame * 0.3) + 1)) / 2;
          ctx.beginPath();
          ctx.moveTo(-ship.size / 2, -thrustAnimation.width / 2);
          ctx.lineTo(-ship.size / 2 - length, 0);
          ctx.lineTo(-ship.size / 2, thrustAnimation.width / 2);
          ctx.closePath();
          ctx.fillStyle = "orange";
          ctx.fill();
          ctx.restore();
          thrustAnimation.frame++;
        }
      }

      function drawExplosion(x, y, scale) {
        if (explosion.active) {
          ctx.save();
          ctx.translate(x, y);
          ctx.scale(scale, scale);
          ctx.beginPath();
          ctx.arc(0, 0, explosion.radius, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${1 - explosion.frame / explosion.duration})`;
          ctx.fill();
          ctx.restore();
        }
      }

      function drawMaze(xOffset, yOffset, scale) {
        ctx.save();
        ctx.translate(xOffset, yOffset);
        ctx.scale(scale, scale);
        ctx.fillStyle = "gray";
        maze.forEach((wall) => {
          ctx.fillRect(wall[0], wall[1], wall[2], wall[3]);
        });
        ctx.restore();
      }

      function drawBalls(xOffset, yOffset, scale) {
        ctx.save();
        ctx.translate(xOffset, yOffset);
        ctx.scale(scale, scale);
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        balls.forEach((ball) => {
          if (!ball[2]) {
            ctx.beginPath();
            ctx.arc(ball[0], ball[1], 5, 0, Math.PI * 2);
            ctx.stroke();
          }
        });
        ctx.restore();
      }

      function drawMiniMap() {
        const miniMapWidth = 150;
        const miniMapHeight = 100;
        const miniMapScale = miniMapWidth / mapWidth;
        ctx.save();
        ctx.translate(10, 10); // Mini-map at top-left with 10px padding
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, miniMapWidth, miniMapHeight);
        drawMaze(0, 0, miniMapScale);
        drawBalls(0, 0, miniMapScale);
        if (ship.visible && !explosion.active) {
          drawShip(ship.x * miniMapScale, ship.y * miniMapScale, miniMapScale);
          drawThrust(ship.x * miniMapScale, ship.y * miniMapScale, miniMapScale);
        }
        if (explosion.active) {
          drawExplosion(explosion.x * miniMapScale, explosion.y * miniMapScale, miniMapScale);
        }
        ctx.restore();
      }

      function update(deltaTime) {
        if (gameState !== 'playing' || ship.frozen) {
          updateExplosion();
          return;
        }

        const turnSpeedPerFrame = (ship.turnSpeed / 80) * deltaTime;
        if (isTurningLeft) ship.targetAngle += turnSpeedPerFrame;
        if (isTurningRight) ship.targetAngle -= turnSpeedPerFrame;
        const angleDiff = (ship.targetAngle - ship.angle + Math.PI * 3) % (Math.PI * 2) - Math.PI;
        ship.angle += angleDiff * 0.2 * deltaTime;

        if (isThrusting) {
          ship.currentThrust += ship.thrustIncrement * deltaTime;
          if (ship.currentThrust > ship.thrust) ship.currentThrust = ship.thrust;
          ship.speedY -= Math.sin(ship.angle) * ship.currentThrust * deltaTime;
          ship.speedX += Math.cos(ship.angle) * ship.currentThrust * deltaTime;
        } else {
          ship.currentThrust = 0;
        }

        ship.speedY += gravity * deltaTime;
        const speed = Math.hypot(ship.speedX, ship.speedY);
        if (speed > ship.maxSpeed) {
          ship.speedX = (ship.speedX / speed) * ship.maxSpeed;
          ship.speedY = (ship.speedY / speed) * ship.maxSpeed;
        }

        const newX = ship.x + ship.speedX * deltaTime;
        const newY = ship.y + ship.speedY * deltaTime;

        if (checkCollision(newX, newY)) {
          gameState = 'gameOver';
          explosion.active = true;
          explosion.x = ship.x;
          explosion.y = ship.y;
          explosion.frame = 0;
          explosion.radius = 0;
          ship.visible = false; // Hide the ship
          timerRunning = false;
          gameOverText.style.display = "block";
          restartBtn.style.display = "block";
		  restartBtn.focus();
          explosionSound.play().catch(error => console.log("Explosion sound play failed:", error));
          return;
        }

        ship.x = newX;
        ship.y = newY;

        checkBallCollision(ship.x, ship.y);
        if (balls.every((ball) => ball[2])) {
          gameState = 'gameWon';
          gameWonText.style.display = "block";
          restartBtn.style.display = "block";
		  restartBtn.focus();
          timerRunning = false;
          updateLeaderboard();
          leaderboardDisplay.style.display = "block";
        }
      }

      function updateExplosion() {
        if (explosion.active) {
          explosion.frame++;
          explosion.radius = (explosion.frame / explosion.duration) * explosion.maxRadius;
          if (explosion.frame >= explosion.duration) {
            explosion.active = false;
          }
        }
      }

      function drawStars() {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white";
        stars.forEach(star => {
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const deltaTime = (timestamp - lastTime) / 16.67;
        lastTime = timestamp;

        // Update elapsedTime while the game is playing and timer is running
        if (gameState === 'playing' && timerRunning) {
          elapsedTime = (Date.now() - startTime) / 1000;
        }

        if (gameState === 'mapSelection') {
          drawStars(); // Draw starry background with random disappearances and slow re-creation
        } else {
          ctx.fillStyle = "black";
          ctx.fillRect(0, 0, canvas.width, canvas.height); // Clear canvas with black for gameplay

          if (gameState !== 'mapSelection') {
            if (explosion.active) updateExplosion();

            const targetCameraX = Math.max(0, Math.min(ship.x - viewWidth / 2, mapWidth - viewWidth));
            const targetCameraY = Math.max(0, Math.min(ship.y - viewHeight / 2, mapHeight - viewHeight));
            cameraX += (targetCameraX - cameraX) * cameraSmoothing;
            cameraY += (targetCameraY - cameraY) * cameraSmoothing;

            const scaleX = canvas.width / viewWidth;
            const scaleY = canvas.height / viewHeight;
            const scale = Math.min(scaleX, scaleY);

            ctx.save();
            ctx.scale(scale, scale);
            ctx.translate(-cameraX, -cameraY);

            drawMaze(0, 0, 1);
            drawBalls(0, 0, 1);
            if (ship.visible && !explosion.active) {
              drawShip(ship.x, ship.y, 1);
              drawThrust(ship.x, ship.y, 1);
            }
            if (explosion.active) {
              drawExplosion(explosion.x, explosion.y, 1);
            }

            ctx.restore();

            if (gameState === 'playing') update(deltaTime);
            drawMiniMap();
            updateTimer(); // Always draw the timer when not in map selection
          }
        }

        requestAnimationFrame(gameLoop);
      }

function restartGame() {
    console.log("Restarting game..."); // Debugging

    // Reset input flags
    isTurningLeft = false;
    isTurningRight = false;
    isThrusting = false;

    // Reset ship state and position
    ship.x = 70;
    ship.y = 366.5;
    ship.angle = Math.PI / 2;
    ship.targetAngle = Math.PI / 2;
    ship.speedX = 0;
    ship.speedY = 0;
    ship.currentThrust = 0;
    ship.frozen = true; // Ensure ship is frozen at the start
    ship.visible = true;

    // Reset game state
    gameState = 'paused'; // Game starts in paused state
    explosion.active = false;
    thrustAnimation.active = false;
    thrustAnimation.frame = 0;

    // Hide UI messages safely
    if (gameOverText) gameOverText.style.display = "none";
    if (gameWonText) gameWonText.style.display = "none";
    if (restartBtn) restartBtn.style.display = "none";
    if (leaderboardDisplay) leaderboardDisplay.style.display = "none";
    if (startMessage) startMessage.style.display = "block"; // Show start message

    // Reset sounds safely
    stopSound(thrustSound);
    stopSound(explosionSound);
    stopSound(blobSound);

    // Reset balls only if currentMapIndex is valid
    if (maps[currentMapIndex]) {
        balls = maps[currentMapIndex].balls.map(pos => [...pos, false]);
    }

    // Reset timer and camera position
    startTime = 0;
    elapsedTime = 0;
    timerRunning = false;
    cameraX = ship.x - viewWidth / 2;
    cameraY = ship.y - viewHeight / 2;

    // Clear canvas to refresh game visuals
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    console.log("Game restarted successfully.");
}


      window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });
    </script>
  </body>
</html>
